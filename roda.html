<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roda de Sorteio</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .wheel-container {
            position: relative;
            width: 100%;
            max-width: 650px;
            aspect-ratio: 1 / 1; /* Mant√©m o cont√™iner quadrado */
        }

        .pointer {
            position: absolute;
            top: -5.1%; /* -28px / 550px */
            left: 50%;
            transform: translateX(-50%);
            width: 10.2%; /* ~56px / 550px */
            height: 10%;  /*  55px / 550px */
            background: #ff4757;
            /* Cria um tri√¢ngulo de forma responsiva e robusta */
            clip-path: polygon(0 0, 100% 0, 50% 100%);
            z-index: 10;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }

        #wheelSVG {
            width: 100%;
            height: 100%;
        }

        #wheel-parts {
            transform-origin: 275px 275px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .speed-control {
            display: flex;
            align-items: center;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .speed-label {
            color: white;
            font-weight: bold;
            font-size: 16px;
            min-width: 120px;
        }

        .speed-slider {
            width: 200px;
            height: 8px;
            border-radius: 5px;
            background: rgba(255,255,255,0.3);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff6b6b;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff6b6b;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .speed-value {
            color: white;
            font-weight: bold;
            font-size: 16px;
            min-width: 60px;
            text-align: center;
        }

        .checkbox-control {
            display: flex;
            align-items: center;
            gap: 10px;
            /* Estilos para consist√™ncia visual com o controle de velocidade */
            background: rgba(255,255,255,0.1);
            padding: 4px 4px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .checkbox-label {
            color: white;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none; /* Impede a sele√ß√£o de texto no label */
        }

        #showLinesCheckbox {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .result {
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-align: center;
            background: rgba(255,255,255,0.1);
            padding: 15px 25px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .title {
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        /* Estilos para o Gerenciador de Itens */
        .item-manager {
            width: 100%;
            max-width: 400px;
            margin-top: 40px;
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }

        .manager-title {
            color: white;
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .item-form {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto 20px; /* Centraliza e mant√©m a margem inferior */
            max-width: 400px;    /* Restringe a largura m√°xima */
        }

        .item-form input {
            flex-grow: 1;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            color: white;
            font-size: 16px;
        }

        .item-form input::placeholder {
            color: rgba(255,255,255,0.7);
        }

        .item-form input:focus {
            outline: none;
            border-color: #ff6b6b;
        }

        .item-form button {
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .item-form button:hover {
            background: #ee5a24;
        }

        .items-table {
            width: 100%;
            border-collapse: collapse;
            color: white;
        }

        .items-table th, .items-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .items-table th {
            font-size: 16px;
            font-weight: bold;
        }

        .items-table td {
            font-size: 14px;
        }

        .items-table tr:last-child td {
            border-bottom: none;
        }

        .remove-btn {
            background: none;
            border: none;
            color: #ff7979;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .remove-btn:hover {
            color: #ff4757;
        }

        .items-table .editable {
            cursor: pointer;
        }
        .items-table .editable:hover {
            background: rgba(255,255,255,0.1);
        }
        .edit-input {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 5px;
            border: 1px solid #ff6b6b;
            background: rgba(0,0,0,0.2);
            color: white;
            font-size: 14px;
        }
        .edit-input:focus {
            outline: none;
        }

    </style>
    <style id="animation-style"></style>
</head>
<body>
    <div class="container">
        <h1 class="title">üéØ Roda de Sorteio</h1>

        <div class="result" id="result">
            Clique no bot√£o PLAY para come√ßar!
        </div>        

        <div class="wheel-container">
            <div class="pointer"></div>
            <svg id="wheelSVG" viewBox="0 0 550 550" style="border-radius:50%; box-shadow: 0 10px 30px rgba(0,0,0,0.3); overflow:visible;">
                <!-- Fatias ser√£o desenhadas via JS -->
            </svg>
        </div>

        <div class="controls">
            <div class="speed-control">
                <label class="speed-label">Velocidade:</label>
                <input 
                    type="range" 
                    id="speedSlider" 
                    class="speed-slider"
                    min="5" 
                    max="60" 
                    value="20" 
                    step="5"
                >
                <span class="speed-value" id="speedValue">20s</span>
            </div>
            <div class="checkbox-control">
                <input type="checkbox" id="showLinesCheckbox" checked>
                <label for="showLinesCheckbox" class="checkbox-label">Mostrar linhas</label>
            </div>
        </div>


    </div>

    <div class="item-manager">
        <h2 class="manager-title">Gerenciar Sorteio</h2>
        <form id="addItemForm" class="item-form">
            <input type="text" id="itemName" placeholder="Nome" required>
            <input type="number" id="itemQuantity" placeholder="Quantidade" min="1" value="1" required>
            <button type="submit">Adicionar</button>
        </form>
        <table class="items-table">
            <thead>
                <tr>
                    <th>Nome</th>
                    <th>Quantidade</th>
                    <th>A√ß√£o</th>
                </tr>
            </thead>
            <tbody id="itemsTableBody">
                <!-- Itens ser√£o adicionados aqui via JS -->
            </tbody>
        </table>
    </div>

    <script>
    (function() {
        const config = {
            selectors: {
                svg: '#wheelSVG',
                wheelParts: '#wheel-parts',
                playButton: '#play-button',
                playSymbol: '#play-symbol',
                animationStyle: '#animation-style',
                result: '#result',
                speedSlider: '#speedSlider',
                speedValue: '#speedValue',
                showLinesCheckbox: '#showLinesCheckbox',
                addItemForm: '#addItemForm',
                itemName: '#itemName',
                itemQuantity: '#itemQuantity',
                itemsTableBody: '#itemsTableBody',
            },
            wheel: {
                cx: 275,
                cy: 275,
                r: 267,
                borderCircle: {
                    r: 271,
                    stroke: '#2f3542',
                    strokeWidth: '8',
                },
                playButtonCircle: {
                    rRatio: 0.20,
                    fill: '#2f3542',
                    stroke: 'white',
                    strokeWidth: '4',
                },
                playIcon: {
                    sizeRatio: 0.08,
                }
            },
            colors: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43', '#10ac84', '#ee5a24', '#0abde3', '#7bed9f', '#2e86de', '#a55eea', '#26de81', '#fc5c65', '#fd79a8'],
            defaultItems: [
                { name: 'Alex', quantity: 10, color: '#ff6b6b' },
                { name: 'Ariel', quantity: 20, color: '#4ecdc4' },
                { name: 'Cris', quantity: 5, color: '#45b7d1' },
                { name: 'Luan', quantity: 15, color: '#feca57' },
                { name: 'Andrea', quantity: 30, color: '#ff9ff3' },
                { name: 'Fran', quantity: 10, color: '#54a0ff' },
            ]
        };

        const state = {
            items: [],
            isSpinning: false,
            currentRotation: 0,
            spinDuration: 20,
            showSubdivisionLines: true,
            winnerText: 'Clique no bot√£o PLAY para come√ßar!',
            editingCell: null, // { index, field }
            newItemName: '',
            newItemQuantity: 1,
        };

        // --- Pure Functions ---
        function calculateFinalRotation(spinDuration, currentRotation) {
            const minSpins = Math.round((3 / 11) * spinDuration + (40 / 11));
            const maxSpins = minSpins + 2;
            const spins = Math.random() * (maxSpins - minSpins) + minSpins;
            const finalAngle = Math.random() * 360;
            return currentRotation + (spins * 360) + finalAngle;
        }

        function calculateWinner(items, finalAngle) {
            const totalQuantity = items.reduce((sum, item) => sum + item.quantity, 0);
            if (totalQuantity === 0) return null;

            const finalPosition = finalAngle % 360;
            const normalizedAngle = (270 - finalPosition + 360) % 360;
            let cumulativeAngle = 0;
            for (const item of items) {
                const sliceSizeInDegrees = (item.quantity / totalQuantity) * 360;
                cumulativeAngle += sliceSizeInDegrees;
                if (normalizedAngle < cumulativeAngle) {
                    return item;
                }
            }
            return null;
        }

        function generateKeyframes(initialRotation, finalRotation) {
            return `
                @keyframes spinAnimation {
                    from { transform: rotate(${initialRotation}deg); }
                    to { transform: rotate(${finalRotation}deg); }
                }
            `;
        }

        function getRandomColor() {
            const usedColors = state.items.map(item => item.color);
            const availableColors = config.colors.filter(color => !usedColors.includes(color));
            if (availableColors.length > 0) {
                return availableColors[Math.floor(Math.random() * availableColors.length)];
            }
            return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
        }

        // --- DOM Update Functions ---
        function renderWheel() {
            const svg = document.querySelector(config.selectors.svg);
            svg.innerHTML = '';
            const wheelParts = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            wheelParts.setAttribute('id', config.selectors.wheelParts.slice(1));
            wheelParts.style.transform = `rotate(${state.currentRotation}deg)`;

            const totalQuantity = state.items.reduce((sum, item) => sum + item.quantity, 0);
            if (totalQuantity > 0) {
                const { cx, cy, r } = config.wheel;
                let currentAngle = 0;

                // STAGE 1: Draw colored slices
                state.items.forEach(item => {
                    const sliceSizeInDegrees = (item.quantity / totalQuantity) * 360;
                    const startAngle = currentAngle;
                    const endAngle = currentAngle + sliceSizeInDegrees;
                    const startRad = (Math.PI / 180) * startAngle;
                    const endRad = (Math.PI / 180) * endAngle;
                    const x1 = cx + r * Math.cos(startRad);
                    const y1 = cy + r * Math.sin(startRad);
                    const x2 = cx + r * Math.cos(endRad);
                    const y2 = cy + r * Math.sin(endRad);
                    const largeArcFlag = sliceSizeInDegrees > 180 ? 1 : 0;
                    const pathData = `M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', pathData);
                    path.setAttribute('fill', item.color);
                    wheelParts.appendChild(path);
                    currentAngle += sliceSizeInDegrees;
                });

                // STAGE 2: Draw lines
                if (state.showSubdivisionLines) {
                    let lineAngle = 0;
                    const anglePerUnit = 360 / totalQuantity;
                    for (let i = 0; i < totalQuantity; i++) {
                        lineAngle += anglePerUnit;
                        const lineRad = (Math.PI / 180) * lineAngle;
                        const x2 = cx + r * Math.cos(lineRad);
                        const y2 = cy + r * Math.sin(lineRad);
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', String(cx));
                        line.setAttribute('y1', String(cy));
                        line.setAttribute('x2', String(x2));
                        line.setAttribute('y2', String(y2));
                        line.setAttribute('stroke', 'rgba(0,0,0,0.2)');
                        line.setAttribute('stroke-width', '1');
                        wheelParts.appendChild(line);
                    }
                }

                // STAGE 3: Draw text
                currentAngle = 0;
                state.items.forEach(item => {
                    const sliceSizeInDegrees = (item.quantity / totalQuantity) * 360;
                    const startAngle = currentAngle;
                    const textAngle = startAngle + sliceSizeInDegrees / 2;
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', String(cx + r / 1.7)); 
                    text.setAttribute('y', String(cy));
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('transform', `rotate(${textAngle}, ${cx}, ${cy})`);
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-size', '16px');
                    text.setAttribute('font-weight', 'bold');
                    text.textContent = item.name;
                    text.style.textShadow = '1px 1px 2px rgba(0,0,0,0.7)';
                    wheelParts.appendChild(text);
                    currentAngle += sliceSizeInDegrees;
                });
            }
            svg.appendChild(wheelParts);

            const borderCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            borderCircle.setAttribute('cx', config.wheel.cx);
            borderCircle.setAttribute('cy', config.wheel.cy);
            borderCircle.setAttribute('r', config.wheel.borderCircle.r);
            borderCircle.setAttribute('fill', 'none');
            borderCircle.setAttribute('stroke', config.wheel.borderCircle.stroke);
            borderCircle.setAttribute('stroke-width', config.wheel.borderCircle.strokeWidth);
            svg.appendChild(borderCircle);

            const playButtonGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            playButtonGroup.setAttribute('id', config.selectors.playButton.slice(1));
            playButtonGroup.setAttribute('cursor', 'pointer');
            if (!state.isSpinning) {
                playButtonGroup.onclick = spinWheel;
            }
            const buttonCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            buttonCircle.setAttribute('cx', config.wheel.cx);
            buttonCircle.setAttribute('cy', config.wheel.cy);
            buttonCircle.setAttribute('r', String(config.wheel.r * config.wheel.playButtonCircle.rRatio));
            buttonCircle.setAttribute('fill', config.wheel.playButtonCircle.fill);
            buttonCircle.setAttribute('stroke', config.wheel.playButtonCircle.stroke);
            buttonCircle.setAttribute('stroke-width', config.wheel.playButtonCircle.strokeWidth);
            playButtonGroup.appendChild(buttonCircle);
            const playSymbol = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            playSymbol.setAttribute('id', config.selectors.playSymbol.slice(1));
            if (state.isSpinning) {
                playSymbol.style.display = 'none';
            }
            const iconSize = config.wheel.r * config.wheel.playIcon.sizeRatio;
            const pathData = `M ${config.wheel.cx - iconSize / 1.5}, ${config.wheel.cy - iconSize} L ${config.wheel.cx + iconSize}, ${config.wheel.cy} L ${config.wheel.cx - iconSize / 1.5}, ${config.wheel.cy + iconSize} Z`;
            playSymbol.setAttribute('d', pathData);
            playSymbol.setAttribute('fill', 'white');
            playButtonGroup.appendChild(playSymbol);
            svg.appendChild(playButtonGroup);
        }

        function renderTable() {
            const tableBody = document.querySelector(config.selectors.itemsTableBody);
            tableBody.innerHTML = '';
            state.items.forEach((item, index) => {
                const row = document.createElement('tr');
                row.setAttribute('data-index', index);
                const isEditing = state.editingCell && state.editingCell.index === index;
                const nameCell = document.createElement('td');
                if (isEditing && state.editingCell.field === 'name') {
                    const input = document.createElement('input');
                    input.className = 'edit-input';
                    input.type = 'text';
                    input.value = item.name;
                    input.addEventListener('blur', (e) => handleEdit(index, 'name', e.target.value));
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') handleEdit(index, 'name', e.target.value);
                        if (e.key === 'Escape') { state.editingCell = null; renderTable(); }
                    });
                    nameCell.appendChild(input);
                    setTimeout(() => input.focus(), 0);
                } else {
                    nameCell.textContent = item.name;
                    nameCell.classList.add('editable');
                    nameCell.dataset.field = 'name';
                }
                const quantityCell = document.createElement('td');
                if (isEditing && state.editingCell.field === 'quantity') {
                    const input = document.createElement('input');
                    input.className = 'edit-input';
                    input.type = 'number';
                    input.value = item.quantity;
                    input.addEventListener('blur', (e) => handleEdit(index, 'quantity', e.target.value));
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') handleEdit(index, 'quantity', e.target.value);
                        if (e.key === 'Escape') { state.editingCell = null; renderTable(); }
                    });
                    quantityCell.appendChild(input);
                    setTimeout(() => input.focus(), 0);
                } else {
                    quantityCell.textContent = item.quantity;
                    quantityCell.classList.add('editable');
                    quantityCell.dataset.field = 'quantity';
                }
                const actionCell = document.createElement('td');
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '&times;';
                removeBtn.dataset.action = 'remove';
                removeBtn.dataset.index = index;
                actionCell.appendChild(removeBtn);
                row.appendChild(nameCell);
                row.appendChild(quantityCell);
                row.appendChild(actionCell);
                tableBody.appendChild(row);
            });
        }

        function renderResult() {
            const result = document.querySelector(config.selectors.result);
            result.innerHTML = state.winnerText;
        }

        function renderForm() {
            const nameInput = document.querySelector(config.selectors.itemName);
            const quantityInput = document.querySelector(config.selectors.itemQuantity);
            nameInput.value = state.newItemName;
            quantityInput.value = state.newItemQuantity;
        }

        function renderControls() {
            const checkbox = document.querySelector(config.selectors.showLinesCheckbox);
            checkbox.checked = state.showSubdivisionLines;
        }

        function renderSpinResult(currentItem) {
            const result = document.querySelector(config.selectors.result);
            result.innerHTML = `Girando... <strong>${currentItem ? currentItem.name : ''}</strong>`;
        }

        // --- Event Handlers & State Changers ---
        function updateSpeed(value) {
            state.spinDuration = parseFloat(value);
            document.querySelector(config.selectors.speedValue).textContent = value + 's';
        }

        function spinWheel() {
            if (state.isSpinning || state.items.length === 0) return;
            state.isSpinning = true;
            state.winnerText = 'Girando...';
            renderResult();
            renderWheel();

            const wheelParts = document.querySelector(config.selectors.wheelParts);
            const animationStyle = document.querySelector(config.selectors.animationStyle);
            const finalRotation = calculateFinalRotation(state.spinDuration, state.currentRotation);
            const keyframes = generateKeyframes(state.currentRotation, finalRotation);

            animationStyle.innerHTML = keyframes;
            wheelParts.style.animation = `spinAnimation ${state.spinDuration}s cubic-bezier(0,-0.01,.41,1) forwards`;
            state.currentRotation = finalRotation;

            requestAnimationFrame(updateResultDuranteSpin);

            wheelParts.addEventListener('animationend', () => {
                const winner = calculateWinner(state.items, finalRotation);
                state.winnerText = `üéâ Resultado: <strong>${winner ? winner.name : 'Nenhum'}</strong>`;
                state.isSpinning = false;
                renderResult();
                renderWheel();
                animationStyle.innerHTML = '';
            }, { once: true });
        }

        function updateResultDuranteSpin() {
            if (!state.isSpinning) return;
            const wheelParts = document.querySelector(config.selectors.wheelParts);
            const transformMatrix = window.getComputedStyle(wheelParts).transform;
            let currentAngle = 0;
            if (transformMatrix !== 'none') {
                const values = transformMatrix.split('(')[1].split(')')[0].split(',');
                currentAngle = Math.atan2(parseFloat(values[1]), parseFloat(values[0])) * (180 / Math.PI);
            }
            const winner = calculateWinner(state.items, currentAngle);
            renderSpinResult(winner);
            requestAnimationFrame(updateResultDuranteSpin);
        }

        function saveItemsToSession() {
            sessionStorage.setItem('rouletteItems', JSON.stringify(state.items));
        }

        function handleAddItem(event) {
            event.preventDefault();
            if (state.newItemName && state.newItemQuantity > 0) {
                state.items.push({ 
                    name: state.newItemName, 
                    quantity: state.newItemQuantity, 
                    color: getRandomColor() 
                });
                state.newItemName = '';
                state.newItemQuantity = 1;
                renderWheel();
                renderTable();
                renderForm();
                saveItemsToSession();
                document.querySelector(config.selectors.itemName).focus();
            }
        }

        function handleEdit(index, field, value) {
            const quantity = parseInt(value, 10);
            if (field === 'name' && value.trim()) {
                state.items[index].name = value.trim();
            } else if (field === 'quantity' && quantity > 0) {
                state.items[index].quantity = quantity;
            }
            state.editingCell = null;
            renderWheel();
            renderTable();
            saveItemsToSession();
        }

        function handleTableClick(event) {
            const target = event.target;
            const dataIndex = target.dataset.index || target.parentElement.dataset.index;
            if (target.dataset.action === 'remove') {
                state.items.splice(parseInt(dataIndex, 10), 1);
                renderWheel();
                renderTable();
                saveItemsToSession();
                return;
            }
            if (target.classList.contains('editable')) {
                state.editingCell = { index: parseInt(dataIndex, 10), field: target.dataset.field };
                renderTable();
            }
        }

        function init() {
            const savedItems = sessionStorage.getItem('rouletteItems');
            if (savedItems) {
                try {
                    const parsedItems = JSON.parse(savedItems);
                    if (Array.isArray(parsedItems) && parsedItems.length > 0) {
                        state.items = parsedItems;
                    }
                } catch (e) {
                    console.error("Erro ao carregar itens da sess√£o:", e);
                    state.items = config.defaultItems;
                }
            } else {
                state.items = config.defaultItems;
            }

            document.querySelector(config.selectors.addItemForm).addEventListener('submit', handleAddItem);
            document.querySelector(config.selectors.itemsTableBody).addEventListener('click', handleTableClick);
            document.querySelector(config.selectors.speedSlider).addEventListener('input', (e) => updateSpeed(e.target.value));
            document.querySelector(config.selectors.showLinesCheckbox).addEventListener('change', (event) => {
                state.showSubdivisionLines = event.target.checked;
                if (!state.isSpinning) {
                    renderWheel();
                }
                renderControls();
            });
            document.querySelector(config.selectors.itemName).addEventListener('input', e => {
                state.newItemName = e.target.value;
            });
            document.querySelector(config.selectors.itemQuantity).addEventListener('input', e => {
                state.newItemQuantity = parseInt(e.target.value, 10) || 1;
            });

            renderWheel();
            renderTable();
            renderResult();
            renderForm();
            renderControls();
            updateSpeed(document.querySelector(config.selectors.speedSlider).value);
        }

        document.addEventListener('DOMContentLoaded', init);
    })();
    </script>
</body>
</html>